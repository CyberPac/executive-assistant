/**
 * Dependency Vulnerability Scanner
 * Executive Assistant Security Testing Framework
 */

import { SecurityTest, SecurityTestResult, SecurityThreatType } from '../core/security-test-framework';
import * as fs from 'fs';
import * as path from 'path';
import { execSync as _execSync } from 'child_process';

export interface DependencyVulnerability {
  id: string;
  package: string;
  version: string;
  vulnerableVersions: string;
  patchedVersion: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  cwe: string[];
  cve: string[];
  title: string;
  description: string;
  references: string[];
  recommendation: string;
  exploitability: number;
  impact: number;
}

export interface LicenseIssue {
  package: string;
  version: string;
  license: string;
  risk: 'low' | 'medium' | 'high';
  description: string;
  recommendation: string;
}

export interface DependencyAuditResult {
  vulnerabilities: DependencyVulnerability[];
  licenseIssues: LicenseIssue[];
  outdatedPackages: OutdatedPackage[];
  summary: {
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    packagesAudited: number;
  };
}

export interface OutdatedPackage {
  package: string;
  current: string;
  wanted: string;
  latest: string;
  location: string;
  riskScore: number;
}

/**
 * Dependency Vulnerability Security Test Suite
 */
export class DependencyVulnerabilityScanner extends SecurityTest {
  private packageJsonPaths: string[] = [];
  private lockfilePaths: string[] = [];

  constructor() {
    super();
    this.findPackageFiles();
  }

  async runTests(): Promise<SecurityTestResult[]> {
    const results: SecurityTestResult[] = [];

    // NPM/Yarn vulnerability audit
    results.push(await this.runNPMAudit());
    
    // License compliance check
    results.push(await this.runLicenseAudit());
    
    // Outdated dependencies check
    results.push(await this.checkOutdatedDependencies());
    
    // Known vulnerable packages check
    results.push(await this.checkKnownVulnerablePackages());
    
    // Dependency tree analysis
    results.push(await this.analyzeDependencyTree());
    
    // Supply chain security check
    results.push(await this.checkSupplyChainSecurity());

    this.results = results;
    results.forEach(result => this.updateMetrics(result));
    
    return results;
  }

  private findPackageFiles(): void {
    const searchPaths = [
      './package.json',
      './package-lock.json',
      './yarn.lock',
      './pnpm-lock.yaml'
    ];

    for (const searchPath of searchPaths) {
      if (fs.existsSync(searchPath)) {
        if (searchPath.includes('package.json')) {
          this.packageJsonPaths.push(searchPath);
        } else {
          this.lockfilePaths.push(searchPath);
        }
      }
    }

    // Search in subdirectories
    this.findPackageFilesRecursive('./');
  }

  private findPackageFilesRecursive(dir: string, maxDepth: number = 3): void {
    if (maxDepth <= 0) return;

    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;
        
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory()) {
          this.findPackageFilesRecursive(fullPath, maxDepth - 1);
        } else if (entry.name === 'package.json') {
          this.packageJsonPaths.push(fullPath);
        } else if (['package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'].includes(entry.name)) {
          this.lockfilePaths.push(fullPath);
        }
      }
    } catch (_error) {
      // Ignore directories we can't read
    }
  }

  private async runNPMAudit(): Promise<SecurityTestResult> {
    const vulnerabilities: DependencyVulnerability[] = [];
    const threats = [];
    
    try {
      // Run npm audit for each package.json
      for (const packagePath of this.packageJsonPaths) {
        const auditResult = await this.simulateNPMAudit(packagePath);
        vulnerabilities.push(...auditResult.vulnerabilities);
      }

      // Convert vulnerabilities to threats
      for (const vuln of vulnerabilities.filter(v => v.severity === 'critical' || v.severity === 'high')) {
        threats.push(this.createThreat(
          SecurityThreatType.DATA_LEAK,
          vuln.severity,
          'vulnerable_dependency',
          vuln.package,
          `${vuln.title}: ${vuln.description}`,
          true,
          false
        ));
      }

      const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
      const status = criticalCount === 0 ? 'passed' : 'failed';

      return this.createTestResult(
        'dependency-audit-001',
        'NPM Dependency Vulnerability Audit',
        status,
        'critical',
        `Found ${vulnerabilities.length} vulnerabilities (${criticalCount} critical)`,
        threats,
        vulnerabilities.map(v => this.createVulnerability(
          'Vulnerable Dependency',
          v.severity,
          v.package,
          `${v.title}: ${v.description}`,
          v.recommendation,
          v.cve[0],
          v.version,
          v.references
        )),
        [],
        [
          'Update vulnerable dependencies immediately',
          'Review dependency update policies',
          'Implement automated dependency scanning',
          'Consider using package-lock.json for version pinning'
        ]
      );

    } catch (error) {
      return this.createTestResult(
        'dependency-audit-001',
        'NPM Dependency Vulnerability Audit',
        'failed',
        'critical',
        `Audit failed: ${error instanceof Error ? error.message : String(error)}`,
        [],
        [this.createVulnerability(
          'Audit Failure',
          'high',
          'dependency_scanner',
          'Unable to perform dependency vulnerability audit',
          'Ensure npm is installed and package.json is valid'
        )],
        [],
        ['Install npm/yarn', 'Validate package.json files', 'Check network connectivity']
      );
    }
  }

  private async runLicenseAudit(): Promise<SecurityTestResult> {
    const licenseIssues: LicenseIssue[] = [];
    const vulnerabilities = [];

    try {
      for (const packagePath of this.packageJsonPaths) {
        const issues = await this.simulateLicenseAudit(packagePath);
        licenseIssues.push(...issues);
      }

      // Convert license issues to vulnerabilities
      for (const issue of licenseIssues.filter(i => i.risk === 'high')) {
        vulnerabilities.push(this.createVulnerability(
          'License Compliance Issue',
          'medium',
          'license_compliance',
          `${issue.package}: ${issue.description}`,
          issue.recommendation,
          undefined,
          undefined,
          ['https://choosealicense.com/', 'https://spdx.org/licenses/']
        ));
      }

      const highRiskCount = licenseIssues.filter(i => i.risk === 'high').length;
      const status = highRiskCount === 0 ? 'passed' : 'failed';

      return this.createTestResult(
        'license-audit-001',
        'Dependency License Compliance Audit',
        status,
        'medium',
        `Found ${licenseIssues.length} license issues (${highRiskCount} high risk)`,
        [],
        vulnerabilities,
        [],
        [
          'Review high-risk license dependencies',
          'Implement license compliance policies',
          'Consider license-compatible alternatives',
          'Maintain license inventory'
        ]
      );

    } catch (error) {
      return this.createTestResult(
        'license-audit-001',
        'Dependency License Compliance Audit',
        'failed',
        'medium',
        `License audit failed: ${error instanceof Error ? error.message : String(error)}`,
        [],
        [this.createVulnerability(
          'License Audit Failure',
          'medium',
          'license_scanner',
          'Unable to perform license compliance audit',
          'Install license checking tools and ensure package metadata is available'
        )],
        [],
        ['Install license checking tools', 'Verify package metadata', 'Check dependency resolution']
      );
    }
  }

  private async checkOutdatedDependencies(): Promise<SecurityTestResult> {
    const outdatedPackages: OutdatedPackage[] = [];
    const vulnerabilities = [];

    try {
      for (const packagePath of this.packageJsonPaths) {
        const outdated = await this.simulateOutdatedCheck(packagePath);
        outdatedPackages.push(...outdated);
      }

      // High-risk outdated packages become vulnerabilities
      for (const pkg of outdatedPackages.filter(p => p.riskScore > 7)) {
        vulnerabilities.push(this.createVulnerability(
          'Outdated Dependency',
          'medium',
          'dependency_management',
          `${pkg.package} is severely outdated (${pkg.current} -> ${pkg.latest})`,
          `Update ${pkg.package} to version ${pkg.latest}`,
          undefined,
          undefined,
          ['https://docs.npmjs.com/updating-packages-downloaded-from-the-registry']
        ));
      }

      const highRiskCount = outdatedPackages.filter(p => p.riskScore > 7).length;
      const status = highRiskCount === 0 ? 'passed' : 'failed';

      return this.createTestResult(
        'outdated-deps-001',
        'Outdated Dependencies Check',
        status,
        'medium',
        `Found ${outdatedPackages.length} outdated packages (${highRiskCount} high risk)`,
        [],
        vulnerabilities,
        [],
        [
          'Update severely outdated dependencies',
          'Implement regular dependency updates',
          'Review breaking changes before updating',
          'Use automated dependency update tools'
        ]
      );

    } catch (error) {
      return this.createTestResult(
        'outdated-deps-001',
        'Outdated Dependencies Check',
        'failed',
        'medium',
        `Outdated check failed: ${error instanceof Error ? error.message : String(error)}`,
        [],
        [this.createVulnerability(
          'Outdated Check Failure',
          'medium',
          'dependency_scanner',
          'Unable to check for outdated dependencies',
          'Ensure package manager is properly configured'
        )],
        [],
        ['Configure package manager', 'Check registry connectivity', 'Verify package.json format']
      );
    }
  }

  private async checkKnownVulnerablePackages(): Promise<SecurityTestResult> {
    const knownVulnerablePackages = [
      { name: 'lodash', versions: ['<4.17.19'], cve: 'CVE-2020-8203', description: 'Prototype pollution vulnerability' },
      { name: 'minimist', versions: ['<0.2.1', '<1.2.3'], cve: 'CVE-2020-7598', description: 'Prototype pollution vulnerability' },
      { name: 'node-fetch', versions: ['<2.6.7', '>=3.0.0 <3.2.0'], cve: 'CVE-2022-0235', description: 'Exposure of sensitive information' },
      { name: 'serialize-javascript', versions: ['<3.1.0'], cve: 'CVE-2020-7660', description: 'Remote code execution' },
      { name: 'handlebars', versions: ['<4.5.3'], cve: 'CVE-2019-20920', description: 'Arbitrary code execution' }
    ];

    const vulnerabilities = [];
    const threats = [];

    try {
      for (const packagePath of this.packageJsonPaths) {
        const packageContent = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
        const allDependencies = {
          ...packageContent.dependencies,
          ...packageContent.devDependencies,
          ...packageContent.peerDependencies
        };

        for (const [depName, depVersion] of Object.entries(allDependencies)) {
          const vulnPackage = knownVulnerablePackages.find(vp => vp.name === depName);
          
          if (vulnPackage && this.isVersionVulnerable(depVersion as string, vulnPackage.versions)) {
            threats.push(this.createThreat(
              SecurityThreatType.DATA_LEAK,
              'high',
              'vulnerable_dependency',
              depName,
              vulnPackage.description,
              true,
              false
            ));

            vulnerabilities.push(this.createVulnerability(
              'Known Vulnerable Package',
              'high',
              'dependency_management',
              `${depName}@${depVersion}: ${vulnPackage.description}`,
              `Update ${depName} to a patched version`,
              vulnPackage.cve,
              depVersion as string,
              [`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${vulnPackage.cve}`]
            ));
          }
        }
      }

      const status = threats.length === 0 ? 'passed' : 'failed';

      return this.createTestResult(
        'known-vulns-001',
        'Known Vulnerable Packages Check',
        status,
        'high',
        `Found ${threats.length} known vulnerable packages`,
        threats,
        vulnerabilities,
        [],
        [
          'Update all known vulnerable packages immediately',
          'Implement automated vulnerability scanning',
          'Subscribe to security advisories',
          'Use tools like Snyk or WhiteSource for continuous monitoring'
        ]
      );

    } catch (error) {
      return this.createTestResult(
        'known-vulns-001',
        'Known Vulnerable Packages Check',
        'failed',
        'high',
        `Known vulnerabilities check failed: ${error instanceof Error ? error.message : String(error)}`,
        [],
        [this.createVulnerability(
          'Vulnerability Check Failure',
          'medium',
          'dependency_scanner',
          'Unable to check for known vulnerable packages',
          'Ensure package.json files are readable and valid'
        )],
        [],
        ['Verify package.json file permissions', 'Check JSON syntax', 'Ensure file system access']
      );
    }
  }

  private async analyzeDependencyTree(): Promise<SecurityTestResult> {
    const vulnerabilities = [];
    let issues = 0;

    try {
      for (const packagePath of this.packageJsonPaths) {
        const analysis = await this.simulateDependencyTreeAnalysis(packagePath);
        
        if (analysis.circularDependencies.length > 0) {
          issues++;
          vulnerabilities.push(this.createVulnerability(
            'Circular Dependencies',
            'medium',
            'dependency_management',
            `Found ${analysis.circularDependencies.length} circular dependencies`,
            'Review and resolve circular dependency issues',
            undefined,
            undefined,
            ['https://nodejs.org/api/modules.html#modules_cycles']
          ));
        }

        if (analysis.duplicateDependencies > 10) {
          issues++;
          vulnerabilities.push(this.createVulnerability(
            'Duplicate Dependencies',
            'low',
            'dependency_management',
            `Found ${analysis.duplicateDependencies} duplicate dependencies`,
            'Deduplicate dependencies to reduce attack surface',
            undefined,
            undefined,
            ['https://docs.npmjs.com/cli/v7/commands/npm-dedupe']
          ));
        }

        if (analysis.deepNestingLevel > 20) {
          issues++;
          vulnerabilities.push(this.createVulnerability(
            'Deep Dependency Nesting',
            'low',
            'dependency_management',
            `Dependency tree has nesting level of ${analysis.deepNestingLevel}`,
            'Review dependency structure and consider flattening',
            undefined,
            undefined,
            ['https://docs.npmjs.com/cli/v7/configuring-npm/install']
          ));
        }
      }

      const status = issues === 0 ? 'passed' : 'failed';

      return this.createTestResult(
        'dependency-tree-001',
        'Dependency Tree Analysis',
        status,
        'medium',
        `Dependency tree analysis completed with ${issues} issues`,
        [],
        vulnerabilities,
        [],
        [
          'Resolve circular dependencies',
          'Deduplicate dependencies where possible',
          'Monitor dependency tree health',
          'Regular dependency tree audits'
        ]
      );

    } catch (error) {
      return this.createTestResult(
        'dependency-tree-001',
        'Dependency Tree Analysis',
        'failed',
        'medium',
        `Dependency tree analysis failed: ${error instanceof Error ? error.message : String(error)}`,
        [],
        [this.createVulnerability(
          'Tree Analysis Failure',
          'medium',
          'dependency_scanner',
          'Unable to analyze dependency tree structure',
          'Ensure dependency resolution tools are available'
        )],
        [],
        ['Install dependency analysis tools', 'Check node_modules structure', 'Verify package manager configuration']
      );
    }
  }

  private async checkSupplyChainSecurity(): Promise<SecurityTestResult> {
    const vulnerabilities = [];
    const threats = [];
    let issues = 0;

    try {
      for (const packagePath of this.packageJsonPaths) {
        const supplyChainIssues = await this.simulateSupplyChainCheck(packagePath);
        
        // Check for suspicious packages
        for (const suspiciousPackage of supplyChainIssues.suspiciousPackages) {
          issues++;
          threats.push(this.createThreat(
            SecurityThreatType.DATA_LEAK,
            'high',
            'malicious_package',
            suspiciousPackage.name,
            `Potentially malicious package: ${suspiciousPackage.reason}`,
            true,
            false
          ));

          vulnerabilities.push(this.createVulnerability(
            'Suspicious Package',
            'high',
            'supply_chain',
            `${suspiciousPackage.name}: ${suspiciousPackage.reason}`,
            'Remove or replace suspicious package with trusted alternative',
            undefined,
            undefined,
            ['https://docs.npmjs.com/security-advisory-database']
          ));
        }

        // Check for packages with poor maintainership
        for (const poorlyMaintained of supplyChainIssues.poorlyMaintainedPackages) {
          vulnerabilities.push(this.createVulnerability(
            'Poorly Maintained Package',
            'medium',
            'supply_chain',
            `${poorlyMaintained.name}: ${poorlyMaintained.issue}`,
            'Consider alternatives or contribute to package maintenance',
            undefined,
            undefined,
            ['https://docs.npmjs.com/about-npm/']
          ));
        }
      }

      const status = threats.length === 0 ? 'passed' : 'failed';

      return this.createTestResult(
        'supply-chain-001',
        'Supply Chain Security Check',
        status,
        'high',
        `Supply chain analysis found ${issues} suspicious packages`,
        threats,
        vulnerabilities,
        [],
        [
          'Remove suspicious packages immediately',
          'Implement package integrity verification',
          'Use private npm registry for internal packages',
          'Monitor package maintainer changes'
        ]
      );

    } catch (error) {
      return this.createTestResult(
        'supply-chain-001',
        'Supply Chain Security Check',
        'failed',
        'high',
        `Supply chain check failed: ${error instanceof Error ? error.message : String(error)}`,
        [],
        [this.createVulnerability(
          'Supply Chain Check Failure',
          'medium',
          'dependency_scanner',
          'Unable to perform supply chain security analysis',
          'Ensure package registry access and analysis tools are available'
        )],
        [],
        ['Configure package registry access', 'Install supply chain analysis tools', 'Verify network connectivity']
      );
    }
  }

  // Simulation methods (in production, these would use actual npm audit, etc.)
  private async simulateNPMAudit(_packagePath: string): Promise<{vulnerabilities: DependencyVulnerability[]}> {
    // Simulate npm audit results
    const vulnerabilities: DependencyVulnerability[] = [];
    
    if (Math.random() > 0.6) {
      vulnerabilities.push({
        id: 'GHSA-c6rq-rjc2-86v2',
        package: 'lodash',
        version: '4.17.15',
        vulnerableVersions: '<4.17.19',
        patchedVersion: '4.17.19',
        severity: 'high',
        cwe: ['CWE-1321'],
        cve: ['CVE-2020-8203'],
        title: 'Prototype Pollution in lodash',
        description: 'Lodash versions prior to 4.17.19 are vulnerable to Prototype Pollution',
        references: ['https://github.com/advisories/GHSA-c6rq-rjc2-86v2'],
        recommendation: 'Update lodash to version 4.17.19 or later',
        exploitability: 7.5,
        impact: 8.2
      });
    }

    return { vulnerabilities };
  }

  private async simulateLicenseAudit(_packagePath: string): Promise<LicenseIssue[]> {
    const licenseIssues: LicenseIssue[] = [];
    
    if (Math.random() > 0.8) {
      licenseIssues.push({
        package: 'some-gpl-package',
        version: '1.0.0',
        license: 'GPL-3.0',
        risk: 'high',
        description: 'GPL license may not be compatible with commercial use',
        recommendation: 'Review GPL license requirements or find alternative'
      });
    }

    return licenseIssues;
  }

  private async simulateOutdatedCheck(_packagePath: string): Promise<OutdatedPackage[]> {
    const outdatedPackages: OutdatedPackage[] = [];
    
    if (Math.random() > 0.5) {
      outdatedPackages.push({
        package: 'express',
        current: '4.16.0',
        wanted: '4.18.0',
        latest: '4.18.2',
        location: 'node_modules/express',
        riskScore: 8.5
      });
    }

    return outdatedPackages;
  }

  private async simulateDependencyTreeAnalysis(_packagePath: string): Promise<{
    circularDependencies: string[];
    duplicateDependencies: number;
    deepNestingLevel: number;
  }> {
    return {
      circularDependencies: Math.random() > 0.8 ? ['package-a -> package-b -> package-a'] : [],
      duplicateDependencies: Math.floor(Math.random() * 20),
      deepNestingLevel: Math.floor(Math.random() * 25) + 10
    };
  }

  private async simulateSupplyChainCheck(_packagePath: string): Promise<{
    suspiciousPackages: Array<{name: string; reason: string}>;
    poorlyMaintainedPackages: Array<{name: string; issue: string}>;
  }> {
    const suspiciousPackages = [];
    const poorlyMaintainedPackages = [];

    if (Math.random() > 0.9) {
      suspiciousPackages.push({
        name: 'suspicious-package',
        reason: 'Recently published with minimal documentation and no GitHub repository'
      });
    }

    if (Math.random() > 0.7) {
      poorlyMaintainedPackages.push({
        name: 'abandoned-package',
        issue: 'No updates in over 2 years, multiple unresolved security issues'
      });
    }

    return { suspiciousPackages, poorlyMaintainedPackages };
  }

  private isVersionVulnerable(currentVersion: string, vulnerableRanges: string[]): boolean {
    // Simplified version comparison - in production, use semver library
    for (const range of vulnerableRanges) {
      if (range.includes('<') && currentVersion.includes('.')) {
        // Basic comparison for demonstration
        const rangeVersion = range.replace('<', '').trim();
        if (this.compareVersions(currentVersion, rangeVersion) < 0) {
          return true;
        }
      }
    }
    return false;
  }

  private compareVersions(v1: string, v2: string): number {
    // Simplified version comparison
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);
    
    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const part1 = parts1[i] || 0;
      const part2 = parts2[i] || 0;
      
      if (part1 < part2) return -1;
      if (part1 > part2) return 1;
    }
    
    return 0;
  }

  /**
   * Generate dependency security report
   */
  public generateDependencySecurityReport(): string {
    const timestamp = new Date().toISOString();
    const allResults = this.getResults();
    
    let report = `
# Dependency Security Report
Generated: ${timestamp}

## Package Files Analyzed
- Package.json files: ${this.packageJsonPaths.length}
- Lock files: ${this.lockfilePaths.length}

## Summary
`;

    const totalVulns = allResults.reduce((sum, result) => sum + result.vulnerabilities.length, 0);
    const criticalVulns = allResults.reduce((sum, result) => 
      sum + result.vulnerabilities.filter(v => v.severity === 'critical').length, 0);

    report += `
- Total Vulnerabilities: ${totalVulns}
- Critical Issues: ${criticalVulns}
- Test Results: ${allResults.length}
`;

    allResults.forEach(result => {
      report += `
## ${result.name}
- Status: ${result.status.toUpperCase()}
- Details: ${result.details}
- Vulnerabilities: ${result.vulnerabilities.length}
`;

      if (result.recommendations.length > 0) {
        report += '\n### Recommendations:\n';
        result.recommendations.forEach(rec => {
          report += `- ${rec}\n`;
        });
      }
    });

    return report;
  }
}